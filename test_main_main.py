# Date: 2025-3-12
# Author: Generated by GoCodeo.

import unittest

import asyncio

from main import main

from unittest import mock

from app.agent.manus import Manus

from unittest.mock import patch

from app.logger import logger

class TestValidPromptProcessing(unittest.TestCase):
	async def test_valid_prompt(self):
		with unittest.mock.patch('builtins.input', return_value='Hello, World!'):
			with unittest.mock.patch('app.agent.manus.Manus.run') as mock_run:
				await main()
				mock_run.assert_called_once_with('Hello, World!')

class TestValidPromptProcessing(unittest.TestCase):
	async def test_valid_prompt(self):
		with unittest.mock.patch('builtins.input', return_value='Hello, agent!'):
			with unittest.mock.patch('app.agent.manus.Manus.run') as mock_run:
				await main()
				mock_run.assert_called_once_with('Hello, agent!')

class TestMainFunction(unittest.TestCase):
	@patch('builtins.input', side_effect=['Hello', 'World', 'exit'])
	@patch('app.agent.manus.Manus.run')
	def test_accepts_multiple_prompts(self, mock_run, mock_input):
		with self.assertLogs('app.logger', level='INFO') as log:
			asyncio.run(main())
		self.assertIn('Goodbye!', log.output)
		self.assertEqual(mock_run.call_count, 2)

class TestValidPromptLogging(unittest.TestCase):
	@patch('builtins.input', side_effect=['Hello, World!'])
	@patch('app.logger.logger.warning')
	@patch('app.agent.manus.Manus.run')
	def test_logging_valid_prompt(self, mock_run, mock_warning, mock_input):
		mock_run.return_value = asyncio.Future()
		mock_run.return_value.set_result(None)
		with self.assertLogs('app.logger.logger', level='WARNING') as log:
			asyncio.run(main())
			self.assertIn('Processing your request...', log.output)
			mock_run.assert_called_once_with('Hello, World!')

