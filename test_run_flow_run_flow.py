# Date: 2025-3-12
# Author: Generated by GoCodeo.

import unittest

import asyncio

import time

from run_flow import run_flow

from unittest import mock

from unittest.mock import patch
 
from app.logger import logger

from app.agent.manus import Manus

from app.flow.base import FlowType

from app.flow.flow_factory import FlowFactory

class TestRunFlow(unittest.TestCase):
	async def test_valid_prompt_processing(self):
		with unittest.mock.patch('builtins.input', return_value='Valid prompt'):
			with unittest.mock.patch('app.flow.flow_factory.FlowFactory.create_flow') as mock_create_flow:
				mock_flow = unittest.mock.Mock()
				mock_flow.execute.return_value = 'Response from valid prompt'
				mock_create_flow.return_value = mock_flow
				result = await run_flow()
				self.assertEqual(result, 'Response from valid prompt')

class TestRunFlow(unittest.TestCase):
	async def test_multiple_valid_prompts(self):
		inputs = ['First prompt', 'Second prompt', 'Third prompt']
		for prompt in inputs:
			with unittest.mock.patch('builtins.input', side_effect=inputs):
				result = await run_flow()
				self.assertIsNotNone(result)
				self.assertIn('Request processed in', result)
				self.assertIn(prompt, result)

class TestRunFlow(unittest.TestCase):
	@patch('builtins.input', side_effect=['exit'])
	@patch('app.logger.logger.info')
	def test_exit_command(self, mock_logger_info, mock_input):
		with self.assertRaises(SystemExit):
			asyncio.run(run_flow())

class TestRunFlow(unittest.TestCase):
	async def test_valid_prompt_processing(self):
		prompt = 'This is a valid prompt.'
		agents = {'manus': Manus()}
		flow = FlowFactory.create_flow(flow_type=FlowType.PLANNING, agents=agents)
		result = await asyncio.wait_for(flow.execute(prompt), timeout=3600)
		self.assertIsNotNone(result)
		self.assertIn('expected_output', result)

class TestRunFlow(unittest.TestCase):
	async def test_valid_prompt_processing(self):
		with unittest.mock.patch('builtins.input', return_value='Valid prompt'):
			with unittest.mock.patch('app.flow.flow_factory.FlowFactory.create_flow') as mock_create_flow:
				mock_flow = unittest.mock.Mock()
				mock_flow.execute.return_value = 'Response from valid prompt'
				mock_create_flow.return_value = mock_flow
				result = await run_flow()
				self.assertEqual(result, 'Response from valid prompt')

class TestRunFlow(unittest.TestCase):
	async def test_multiple_valid_prompts(self):
		prompts = ['First prompt', 'Second prompt', 'Third prompt']
		for prompt in prompts:
			with unittest.mock.patch('builtins.input', return_value=prompt):
				result = await run_flow()
				self.assertIsNotNone(result)
				self.assertIn('Request processed in', result)
				self.assertIn(prompt, result)

class TestRunFlow(unittest.TestCase):
	@patch('builtins.input', side_effect=['exit'])
	@patch('app.logger.logger.info')
	def test_exit_command(self, mock_logger_info, mock_input):
		with self.assertRaises(SystemExit):
			run_flow()
		mock_logger_info.assert_called_with('Goodbye!')

class TestRunFlow(unittest.TestCase):
	async def test_valid_prompt_processing(self):
		prompt = 'This is a valid prompt.'
		agents = {'manus': Manus()}
		flow = FlowFactory.create_flow(flow_type=FlowType.PLANNING, agents=agents)
		result = await asyncio.wait_for(flow.execute(prompt), timeout=3600)
		self.assertIsNotNone(result)
		self.assertIn('expected_output', result)

